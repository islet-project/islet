# FIXME

THIS FILE NEEDS TO BE VERIFIED.

# Introduction

The process consists of several parts:

* provisioning
* gathering measurements
* feeding measurements to veraison and realm verifier
* running realm to verify
* running verification services (veraison/realm verifier)
* verification itself

It is best and even sometimes required that all the required repos are placed in
one directory. I'll call it `CCA` and it will be referred throughout this file.

The following repos will be used (they have some additional dependencies like
`rust-rsi`, `ratls` and `realm-verfier`, but it's not required to clone those
repos manually):

* Islet: https://github.com/Samsung/islet that provides:

	* the whole SW/FW stack and scripts for running the emulated environment under the FVP
	* Islet HES https://github.com/Samsung/islet/tree/main/hes
	* kvmtool-rim-measurer from https://github.com/Samsung/islet/tree/main/third-party/


* Islet Remote Attestation: https://github.com/Samsung/islet that provides:

	* rocli: https://github.com/Samsung/islet-ra/tree/main/tools/rocli
	* realm-verifier: https://github.com/Samsung/islet-ra/tree/main/lib/realm-verifier
	* ratls: https://github.com/Samsung/islet-ra/tree/main/lib/ratls
	* rust-rsi: https://github.com/Samsung/islet-ra/tree/main/lib/rust-rsi

* veraison: https://github.com/veraison/services

# Provisioning

This is emulated by generating CPAK public key using one of camellia-hes
utilities:

    CCA/islet/hes/cpak-generator $ cargo run

This will by default generate a CPAK using dummy GUK and dummy BL2 hash files
from `Islet/hes/res` directory and save both key binary and PEM format
respectively as:

    CCA/islet/hes/out/cpak_public.bin
    CCA/islet/hes/out/cpak_public.pem

# Gathering measurements

There are 2 things we need to measure here. Platform and realm.

## Plaftorm measurement

The platform measurement is done by getting the whole CCA token. Platform
measurements are saved there.

This is performed by some specifically prepared realm (e.g. one provided by
`Islet/scripts/fvp-cca`). To do this do the following:

    CCA/islet $ ./scripts/init.sh
    CCA/islet $ ./scripts/fvp-cca --normal-world=linux --realm=linux --rmm=islet --hes

The first command will initialize the scripts and download all required
components. The second command will build the platform and the realm and run the FVP emulator
and HES application.

When the FVP linux is booted we need to run the realm:

    $ ./launch-realm.sh

This will take a lot of time (FVP is slow). Wait until you have a realm
shell. Then load RSI module and get the token:

    # cd /shared
    /shared # inmod rsi.ko
    /shared # ./rsictl attest -o token.bin

For the token part challenge value will be randomized, but in here it doesn't
matter. Now we can kill the FVP (ctrl-c on the FVP terminal). Eventually the
following command may be required as FVP doesn't always close cleanly:

    $ pkill -9 -i fvp

The generated token is saved as the following file:

    CCA/islet/out/shared/token.bin

## Realm measurement

Realm measurement is done by generating a json file containing realm information
that will be fed to realm verifier.

This is performed by a small helper program called `kvmtool-rim-measurer`. It basically
runs a modified lkvm tool that calculates and displays the RIM
value. The process looks as follows:

* generate/get the realm you want to use (for now generated by fvp-cca script,
  those files can be taken from `CCA/islet/out/shared`,
  `Image.realm initramfs-realm.cpio.gz realm.sh`)
* Build the kvmtool-rim-measurer tool according to the description https://github.com/Samsung/islet-asset/blob/3rd-kvmtool-rim-measurer/BUILD-RIM-MEASURER
* Create a dedicated directory for realm files (e.g. `CCA/islet/out/rim-extractor``) and copy the realm files we want to measure to that folder
* copy the resulting `lkvm-rim-measurer` to the `CCA/islet/out/rim-extractor` folder
* substitute `lkvm` to `lkvm-rim-measurer` in the `CCA/islet/out/rim-extractor/realm.sh` script
* get into the `CCA/islet/out/rim-extractor` folder and run the `realm.sh` script
* The `lkvm-rim-measurer`` will display the resulting RIM (e.g. RIM: F58AF6D6A022F113627B1E0B1E0D9B9A1BFB460207AC29721E84BCEF4B4F5CE08351684444BC11CF329D1D4C807BB621807916C2DF4F56B7326E8D16692546A8)

Create a `realm.json` file according to the below template and replace the `TO_BE_REPLACED` term with the extracted RIM value.

```json
{
    "version": "0.1",
    "issuer": {
        "name": "Samsung",
        "url": "https://cca-realms.samsung.com/"
    },
    "realm": {
        "uuid": "f7e3e8ef-e0cc-4098-98f8-3a12436da040",
        "name": "Data Processing Service",
        "version": "1.0.0",
        "release-timestamp": "2024-11-27T05:21:31Z",
        "attestation-protocol": "HTTPS/RA-TLSv1.0",
        "port": 8088,
        "reference-values": {
            "rim": "TO_BE_REPLACED",
            "rems": [
                [
                    "0000000000000000000000000000000000000000000000000000000000000000",
                    "0000000000000000000000000000000000000000000000000000000000000000",
                    "0000000000000000000000000000000000000000000000000000000000000000",
                    "0000000000000000000000000000000000000000000000000000000000000000"
                ],
                [
                    "0000000000000000000000000000000000000000000000000000000000000000",
                    "7d43aefe4c6a955cd0753bccee2e707232d2b44b84c4607ac925597419ac104d",
                    "0000000000000000000000000000000000000000000000000000000000000000",
                    "9e6f6535ee6cf18be0eae95d0a2fd6876ccdc216a172e8f15607fe1a814d0b6c"
                ]
            ],
            "hash-algo": "sha-256"
        }
    }
}
```

The resulting json should be saved as the following file:

    CCA/islet/out/rim-extractor/realm.json

Caveat: only RIM is supported for now, the REMs are placeholders.

# Provisioning/Measurement summary

Those 2 processes should end with the following things

* Prepared realm that won't be modified anymore:
  `Image.realm initramfs-realm.cpio.gz lkvm realm.sh`
  For now we use the one generated by fvp-cca
* Public CPAK key: `cpak_public.bin cpak_public.pem`
* Platform measurement: `token.bin`
* Realm measurement: `realm.json`

Those token and measurement files should be _sent_ to verification services
using a _safe_ communication channel.

# Running realm to verify

This is done in the same way we run realm to get the token.

Run the FVP with HES and network this time:

    Islet $ ./scripts/fvp-cca --normal-world=linux --realm=linux-net --rmm=islet --hes

When FVP is booted run the realm:

    # ./launch-realm.sh

Load the RSI module:

    # cd /shared
    /shared # inmod rsi.ko

# Running and provisioning verification services (Veraison, realm-verifier)

First of all, before deploying Veraison, apply a patch to Veraison code (https://github.com/veraison/services):

    CCA/services $ cat ../islet-ra/examples/veraison/veraison-patch | git apply

Then it's possible to deploy a Veraison Docker and source some useful
commands from veraison env file:

    CCA/services $ make docker-deploy
    CCA/services $ source deployments/docker/env.bash

Check if all 3 veraison services are running:

    $ veraison status
             vts: running
    provisioning: running
    verification: running

Now install go dependencies for rocli script:

    $ go install github.com/veraison/corim/cocli@latest
    $ go install github.com/veraison/ear/arc@latest
    $ go install github.com/veraison/evcli@latest

And run provisioning of token and cpak in PEM format:

    CCA/islet-ra/examples/veraison/provisioning $ ./run.sh -t <path/to/token.bin> -k <path/to/cpak_public.pem>

This will provision a reference token and public CPAK to allow
Veraison verification.

It's possible to see current values stored in Veraison:

    $ veraison stores

And if required, they also should be cleared before they can be
provisioned again:

    $ veraison clear-stores

Run reliant-party, which is provisioned with `realm.json` and
acts as Reliant Party with communication to realm and Veraison
services (this binary takes several parameters, most should not be of
any concern apart from passing latest reference values in `realm.json`):

     CCA/islet-ra/examples/veraison/reliant-party $ cargo run -- -r <path/to/realm.json>

If needed, '-b' option can be used to pass different network interface binding:

    CCA/islet-ra/examples/veraison/reliant-party $ cargo run -- -r <path/to/realm.json> -b <LOCAL_IP:PORT>

Reliant-party awaits on given IP:PORT for communication from Realm and
utilizes our `ratls` Rust library and `realm-verifier` library (for `realm.json`
reference values verification) to verify client CCA token.

# Verification itself

On the realm side (the one we already run) just trigger the verification
process. This is done using `realm-application` (`CCA/islet-ra/examples/veraison/realm-application`).
It will initialize RATLS connection to verification service by performing the necessary steps:

* receive challenge value from verification service
* request the token from RMM/TF-A/HES using the challenge
* send the received token to verification service
* establish safe connection if verification services agrees to do so

This is done with the following command on the realm:

    shared # ./realm-application root-ca.crt -u <SERVER_IP:PORT>

That command will take a very long time as Realm on FVP is slow and it does
asymmetric cryptography (RSA key generation).

# Verification success

When verification succeeds, both `realm-application` and `realm-verifier` should not
output any errors. For both binaries you can set RUST_LOG
environmental variable to change log level (info, debug):

Realm:

    shared # RUST_LOG=info ./realm-application ra-tls -r root-ca.crt -u <SERVER_IP:PORT>

Reliant party:

    CCA/islet-ra/examples/veraison/reliant-party $ RUST_LOG=info cargo run -- -r <path/to/realm.json> -b <LOCAL_IP:PORT>

With that log level realm client should report successful socket write
with 'GIT' message and verifying server should output that message.
