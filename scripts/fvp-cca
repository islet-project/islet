#!/usr/bin/env python3

import os
import sys

# Ensure the script's directory is in sys.path to find cca_base
script_dir = os.path.dirname(os.path.abspath(__file__))
if script_dir not in sys.path:
    sys.path.insert(0, script_dir)

from cca_base import CCAPlatform
from config import * # General config
from config_fvp import * # FVP specific config
from initrd import prepare_initrd # FVP uses prepare_initrd

# FVP specific paths that might be referenced by CCAPlatform or need to be set
# These are typically defined in config_fvp.py but ensuring they are accessible.
# CCAPlatform defines placeholders, these will override if imported correctly.
# For example, PREBUILT_EDK2, ACS_HOST, FVP_DIR, FVP_BIN, etc.

class FVPPlatform(CCAPlatform):
    def __init__(self):
        self.PREBUILT_EDK2 = PREBUILT_EDK2
        super().__init__()
        # FVP-specific initializations if any
        # Ensure all necessary FVP paths from config_fvp are available.
        # For example, self.FVP_DIR = FVP_DIR (already imported)

    @property
    def platform_name(self):
        return "fvp"

    @property
    def hes_address(self):
        return "127.0.0.1:5002"

    def default_optee_build_args(self, target=""):
        args = [
            "-j%d" % multiprocessing.cpu_count(), "-f",
            "fvp.mk",
        ]
        if target != "":
            args.append(target)
        args.append("ROOT=" + ROOT)
        args.append("BUILD_PATH=" + BUILD_SCRIPT)
        args.append("LINUX_PATH=" + NW_LINUX)
        args.append("TF_A_PATH=" + TF_A)
        args.append("FVP_USE_BASE_PLAT=y")
        args.append("FVP_PATH=" + FVP_DIR)
        args.append("BOOT_IMG=%s/boot.img" % OUT)
        args.append("GRUB_CONFIG_PATH=%s" % OUT)
        return args

    def prepare_bootloaders(self, rmm, bl33, hes):
        args = []

        if hes:
            args = [
                "CROSS_COMPILE=%s" % CROSS_COMPILE,
                "PLAT=fvp",
                "ENABLE_RME=1",
                "FVP_HW_CONFIG_DTS=fdts/fvp-base-gicv3-psci-1t.dts",
                "DEBUG=0", # RSS build is typically release
                "BL33=%s" % bl33,
                "PLAT_RSE_COMMS_USE_SERIAL=1",
                "MBEDTLS_DIR=%s" % MBEDTLS,
            ]
        else:
            args = [
                "CROSS_COMPILE=%s" % CROSS_COMPILE,
                "PLAT=fvp",
                "ENABLE_RME=1",
                "FVP_HW_CONFIG_DTS=fdts/fvp-base-gicv3-psci-1t.dts",
                "DEBUG=1",
                "BL33=%s" % bl33]

        if rmm == "islet":
            args += "RMM=%s/rmm.bin" % OUT,
        elif rmm == "tf-rmm":
            args += "RMM=%s/tf-rmm.img" % OUT,

        args += ["all", "fip"]

        bl_list = ["bl1.bin", "fip.bin"]
        print(f"[!] Building FVP bootloaders({', '.join(bl_list)})... ")

        outdir = ""
        if hes:
            self.make(TF_A_RSS, args)
            outdir = os.path.join(TF_A_RSS, "build/fvp/release")
        else:
            self.make(TF_A, args)
            outdir = os.path.join(TF_A, "build/fvp/debug")

        for bootloader in bl_list:
            outbin = os.path.join(outdir, bootloader)
            if not os.path.exists(outbin):
                print(f"[!] Failed to build: {outbin}")
                sys.exit(1)
            self.run(["cp", outbin, OUT], cwd=ROOT)

    def prepare_tf_rmm(self):
        self.run(["./scripts/build-tf-rmm.sh", CROSS_COMPILE], cwd=ROOT)

    def prepare_grub_config(self, rmm): # FVP specific
        grubdir = os.path.join(BUILD_SCRIPT, "fvp", "grub")
        if rmm == "islet":
            self.run(["cp", os.path.join(grubdir, "grub-hostctxt.cfg"), os.path.join(OUT, "grub.cfg")], cwd=ROOT)
        else:
            self.run(["cp", os.path.join(grubdir, "grub.cfg"), OUT], cwd=ROOT)

    def prepare_nw_linux(self):
        self.prepare_grub_config(self.args.rmm) # FVP specific
        build_args_linux = self.default_optee_build_args("linux")
        print("[!] Building linux for FVP...")
        self.make(BUILD_SCRIPT, build_args_linux)

        self.run(["cp", PREBUILT_GRUB, OUT], cwd=ROOT) # PREBUILT_GRUB from config_fvp
        print("[!] Building initrd for FVP...")
        prepare_initrd(ROOT, OUT, self.args.realm_launch, self.args.normal_world == "linux-net", self.args.platform_ip, self.args.host_tap_ip)

        build_args = self.default_optee_build_args("boot-img")
        print("[!] Building boot image for FVP...")
        self.make(BUILD_SCRIPT, build_args)

    def prepare_tap_network(self):
        args = self.args
        print("[!] Configuring a tap network for FVP...")
        self.run(["./scripts/configure_tap.sh", args.host_ip, args.host_tap_ip, args.platform_ip, args.route_ip, args.gateway, args.ifname], cwd=ROOT)

    def prepare_run_arguments(self):
        run_args = []
        if self.args.debug:
            print("[!] Enabling FVP debug...")
            run_args += ["--cadi-server"]
        if self.args.trace_toggle:
            print("[!] Enabling FVP trace with toggle...")
            run_args += self._prepare_trace_toggle()
        elif self.args.trace:
            print("[!] Enabling FVP trace...")
            run_args += self._prepare_trace()
        if self.args.no_telnet:
            print("[!] Disabling FVP telnet...")
            run_args += ["-C", "bp.terminal_0.start_telnet=0",
                    "-C", "bp.terminal_1.start_telnet=0",
                    "-C", "bp.terminal_2.start_telnet=0",
                    "-C", "bp.terminal_3.start_telnet=0"]
        elif self.args.hes: # HES implies disabling telnet 2
            print("[!] Using HES, disabling FVP telnet 2...")
            run_args += ["-C", "bp.terminal_2.start_telnet=0"]
        return run_args

    def _prepare_trace(self): # Internal helper for FVP trace
        return [
            "--plugin", "%s" % TRACE_LIB,
            "-C", "TRACE.TarmacTrace.trace_events=1",
            "-C", "TRACE.TarmacTrace.trace_instructions=1",
            "-C", "TRACE.TarmacTrace.start-instruction-count=100000000",
            "-C", "TRACE.TarmacTrace.trace_core_registers=1",
            "-C", "TRACE.TarmacTrace.trace_vfp=1",
            "-C", "TRACE.TarmacTrace.trace_mmu=0",
            "-C", "TRACE.TarmacTrace.trace_loads_stores=1",
            "-C", "TRACE.TarmacTrace.trace_cache=0",
            "-C", "TRACE.TarmacTrace.updated-registers=1",
            "-C", "TRACE.TarmacTrace.trace-file=%s/trace.log" % OUT,
        ]

    def _prepare_trace_toggle(self): # Internal helper for FVP trace toggle
        if not os.path.isfile(TOGGLE_LIB):
            pair = TOGGLE_LIB.split(PLUGIN_PATH)
            toggle_name = pair[1]
            print("File not found: %s" % toggle_name)
            print("Please put %s in %s" % (toggle_name, PLUGIN_PATH))
            print("The library can be found by installing FastModelsPortfolio_11.25 "
                  "which requires license agreement")
            sys.exit(1)
        return [
            "--plugin", "%s" % TRACE_LIB,
            "-C", "TRACE.TarmacTrace.trace_atomic=0",
            "-C", "TRACE.TarmacTrace.trace_bte=0",
            "-C", "TRACE.TarmacTrace.trace_cache=0",
            "-C", "TRACE.TarmacTrace.trace_core_registers=0",
            "-C", "TRACE.TarmacTrace.trace_cp15=0",
            "-C", "TRACE.TarmacTrace.trace_dap=0",
            "-C", "TRACE.TarmacTrace.trace_ete=0",
            "-C", "TRACE.TarmacTrace.trace_events=0",
            "-C", "TRACE.TarmacTrace.trace_exception_reasons=0",
            "-C", "TRACE.TarmacTrace.trace_gicv3=0",
            "-C", "TRACE.TarmacTrace.trace_gpt=0",
            "-C", "TRACE.TarmacTrace.trace_hacdbs=0",
            "-C", "TRACE.TarmacTrace.trace_hdbss=0",
            "-C", "TRACE.TarmacTrace.trace_loads_stores=0",
            "-C", "TRACE.TarmacTrace.trace_mmu=0",
            "-C", "TRACE.TarmacTrace.trace_spe=0",
            "-C", "TRACE.TarmacTrace.trace_tag_loads_stores=0",
            "-C", "TRACE.TarmacTrace.trace_vfp=0",
            "-C", "TRACE.TarmacTrace.unbuffered=1",
            "-C", "TRACE.TarmacTrace.trace-file=%s/trace.log" % OUT,
            "--plugin", "%s" % TOGGLE_LIB,
            "-C", "TRACE.ToggleMTIPlugin.disable_mti_from_start=1",
            "-C", "TRACE.ToggleMTIPlugin.use_hlt=1",
            "-C", "TRACE.ToggleMTIPlugin.hlt_imm16=5",
            "-C", "cluster0.cpu0.enable_trace_special_hlt_imm16=1",
            "-C", "cluster0.cpu0.trace_special_hlt_imm16=5",
        ]

    # https://developer.arm.com/documentation/109246/0100/Toolchains-and-model-support/How-to-run-an-SME-application
    def run_tf_a_tests(self):
        print("[!] Running FVP for tf-a-tests...")
        run_args = [
            FVP_BIN,  # FVP_BIN from config_fvp
            "--plugin", "%s" % SVE_LIB,
            "-C", "bp.flashloader0.fname=%s/fip.bin" % OUT,
            "-C", "bp.secureflashloader.fname=%s/bl1.bin" % OUT,
            "-C", "SVE.ScalableVectorExtension.veclen=8", # to test SVE
            "-C", "SVE.ScalableVectorExtension.enable_at_reset=1",
            "-C", "SVE.ScalableVectorExtension.has_sme=1", # to test SME
            "-C", "cluster0.has_arm_v9-2=1",
            "-C", "cluster1.has_arm_v9-2=1",
            "-C", "cluster0.has_enhanced_pac=1",
            "-C", "cluster1.has_enhanced_pac=1",
            "-C", "cluster0.has_pointer_authentication=1",
            "-C", "cluster1.has_pointer_authentication=1",
            "-f", FVP_CONFIG,  # FVP_CONFIG from config_fvp
            "-C", "cluster0.NUM_CORES=4", # overwrite # of cores in FVP_CONFIG
            "-C", "cluster1.NUM_CORES=4",
            "-Q", "1000",
        ]
        run_args += self.prepare_run_arguments()
        self.run(run_args, cwd=FVP_DIR)  # FVP_DIR from config_fvp

    def run_nw_linux(self):
        args = self.args
        print("[!] Running FVP for linux...")
        fvp_args = [
            FVP_BIN,
            "--plugin", "%s" % SVE_LIB,
            "-C", "bp.flashloader0.fname=%s/fip.bin" % OUT,
            "-C", "bp.secureflashloader.fname=%s/bl1.bin" % OUT,
            "-C", "bp.virtioblockdevice.image_path=%s/boot.img" % OUT,
            "-C", "bp.virtiop9device.root_path=%s" % SHARED_PATH,
            "-f", FVP_CONFIG,
            "-Q", "1000",
        ]
        fvp_args += self.prepare_run_arguments()
        self.run(fvp_args, cwd=FVP_DIR)

    def run_nw_linux_net(self):
        args = self.args
        user_name = os.environ['USER']
        self.prepare_tap_network()
        print(f"[!] Running FVP for linux with the tap network for user {user_name}...")
        fvp_args = [
            FVP_BIN,
            "-C", "bp.flashloader0.fname=%s/fip.bin" % OUT,
            "-C", "bp.secureflashloader.fname=%s/bl1.bin" % OUT,
            "-C", "bp.virtioblockdevice.image_path=%s/boot.img" % OUT,
            "-C", "bp.virtiop9device.root_path=%s" % SHARED_PATH,
            "-C", "bp.virtio_net.hostbridge.interfaceName=ARM%s" % user_name,
            "-C", "bp.virtio_net.enabled=1",
            "-f", FVP_CONFIG,
            "-Q", "1000",
        ]
        fvp_args += self.prepare_run_arguments()
        self.run(fvp_args, cwd=FVP_DIR)

    def run_acs(self):
        print("[!] Running FVP for ACS...")
        run_args = [
            ACS_RUN,  # ACS_RUN from config_fvp
            "--model", FVP_BIN,  # FVP_BIN from config_fvp
            "--bl1", "%s/bl1.bin" % OUT,
            "--fip", "%s/fip.bin" % OUT,
            "--acs_build_dir", ACS_BUILD,
        ]  # ACS_BUILD from config_fvp
        if self.args.debug:
            print("[!] Enabling FVP ACS debug...")
            run_args += ["--debug"]
        if self.args.trace_toggle:
            print("[!] Enabling FVP ACS trace with toggle...")
            run_args += ["--trace-toggle"]
        elif self.args.trace:
            print("[!] Enabling FVP ACS trace...")
            run_args += ["--trace"]
        if self.args.no_telnet:
            print("[!] Disabling FVP ACS telnet...")
            run_args += ["--no_telnet"]
        self.run(run_args, cwd=ROOT)

    def place_prebuilt_at_shared(self):
        super().place_prebuilt_at_shared() # Call common part
        # FVP specific prebuilt items
        self.run([f"cp", f"{PREBUILT}/fvp-base-revc.dtb", OUT], cwd=ROOT)
        self.run([f"cp", PREBUILT_GRUB, OUT], cwd=ROOT) # PREBUILT_GRUB from config_fvp


    def _clean_platform_tf_a(self):
        self.run(["make", "distclean"], cwd=TF_A)

    def _clean_nw_linux(self):
        # For FVP, nw-linux cleaning uses optee_build_args
        make_args_base = self.default_optee_build_args()
        current_make_args = list(make_args_base) # Make a copy
        current_make_args.append("linux-clean")
        current_make_args.append("boot-img-clean")
        self.make(BUILD_SCRIPT, current_make_args)

    def _clean_tf_rmm(self):
        self.run(["rm", "-rf", "build"], cwd=TF_RMM)


    def add_platform_arguments(self, parser):
        parser.add_argument("--trace", "-t", help="Using FVP trace component", action="store_true")
        parser.add_argument("--trace-toggle", "-tt", help="Using FVP trace component with toggle", action="store_true")
        parser.add_argument("--no-telnet", help="Do not use FVP telnet", action="store_true")
        parser.add_argument("--fvp-ip", "-fip", help="the ip address that is going to be assigned to the platform host (e.g. fvp, qemu)", default="192.168.10.5", dest="platform_ip") # Renamed conceptually
        parser.add_argument("--fvp-tap-ip", "-ftip", help="the ip address for tap device in platform", default="192.168.20.1", dest="platform_tap_ip") # Renamed conceptually

if __name__ == "__main__":
    # Import multiprocessing here as it's used in default_optee_build_args
    # which might be called during CCAPlatform.main() when creating an instance for the parser.
    import multiprocessing 
    CCAPlatform.main(FVPPlatform)
