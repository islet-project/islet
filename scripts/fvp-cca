#!/usr/bin/env python3

import argparse
import glob
import multiprocessing
import os
import subprocess
import sys

from config import *
from os import environ

os.makedirs(OUT, exist_ok=True)

def run(cmd, cwd, new_env=None):
    process = subprocess.run(cmd, cwd=cwd,
                       stderr=subprocess.STDOUT,
                       stdout=subprocess.PIPE,
                       universal_newlines=True,
                       env=new_env,
                       check=False)
    if process.returncode != 0:
        print("[!] Failed to run: %s @ %s" % (cmd, cwd))
        print(process.stdout)
        sys.exit(1)

def make(srcdir, extra=None):
    args = ["make"]
    if extra:
        args += extra
    run(args, cwd=srcdir)

def prepare_tf_a_tests(realm):
    srcdir = TF_A_TESTS
    outbin = TFTF_BIN

    args = [
        "CROSS_COMPILE=%s" % CROSS_COMPILE,
        "PLAT=fvp",
        "DEBUG=1",
        "all",
    ]

    if realm != "rsi-test":
        args += ["pack_realm"]

    print("[!] Building tf-a-tests...")
    make(srcdir, args)

    if not os.path.exists(outbin):
        print("[!] Failed to build: %s" % outbin)
        sys.exit(1)

    # Pack realm to tftf
    if realm == "rsi-test":
        tftf_max_size = 10485760
        args = [
            'dd',
            'if=%s' % RSI_TEST_BIN,
            'of=%s' % outbin,
            'obs=1',
            'seek=%s' % tftf_max_size
        ]
        run(args, cwd=ROOT)

def prepare_rsi_test():
    run(["cargo", "build", "--release"], cwd=RSI_TEST)
    run(["%sobjcopy" % CROSS_COMPILE, "-O", "binary",
         "%s/aarch64-unknown-none-softfloat/release/rsi-test" % OUT,
         RSI_TEST_BIN],
         cwd=ROOT)

    os.makedirs("%s/realm" % OUT, exist_ok=True)
    run(["cp", RSI_TEST_BIN, "%s/realm" % OUT], cwd=ROOT)

    if not os.path.exists(RSI_TEST_BIN):
        print("[!] Failed to build rsi-test")
        sys.exit(1)

def prepare_realm(name):
    print("[!] Building realm(%s)... " % name)
    if args.realm == "rsi-test":
        prepare_rsi_test()
    else:
        srcdir = os.path.join(REALM, name)
        run(["make"], cwd=srcdir)
        run(["make", "install"], cwd=srcdir)

def prepare_sdk():
    print("[!] Building SDK...")
    make(SDK, ["fvp"])

    print("[!] Building RSI kernel module...")
    make(RSI_KO)

def prepare_bootloaders(rmm, bl33):
    args = [
        "CROSS_COMPILE=%s" % CROSS_COMPILE,
        "PLAT=fvp",
        "ENABLE_RME=1",
        "FVP_HW_CONFIG_DTS=fdts/fvp-base-gicv3-psci-1t.dts",
        "DEBUG=1",
        "BL33=%s" % bl33,
    ]

    if rmm == "islet":
        args += "RMM=%s/rmm.bin" % OUT,

    elif rmm == "tf-rmm":
        args += "RMM=%s/tf-rmm.img" % OUT,

    args += ["all", "fip"]

    bl_list = ["bl1.bin", "fip.bin"]
    print("[!] Building bootloaders(%s)... " % ', '.join(bl_list))
    make(TF_A, args)

    outdir = os.path.join(TF_A, "build/fvp/debug")
    for bootloader in bl_list:
        outbin = os.path.join(outdir, bootloader)
        if not os.path.exists(outbin):
            print("[!] Failed to build: %s" % outbin)
            sys.exit(1)

        run(["cp", outbin, OUT], cwd=ROOT)

def prepare_rmm(rmm):
    print("[!] Building realm management monitor...: %s" % rmm)

    if rmm == "islet":
        run(["cargo", "build", "--release"], cwd=RMM)
        run(["%sobjcopy" % CROSS_COMPILE, "-O", "binary",
             "%s/aarch64-unknown-none-softfloat/release/fvp" % OUT,
             "%s/rmm.bin" % OUT],
             cwd=ROOT)
    elif rmm == "tf-rmm":
        run(["./scripts/build-tf-rmm.sh", CROSS_COMPILE], cwd=ROOT)

def prepare_nw_linux(fvp_ip, host_ip):
    args = [
        "-j%d" % multiprocessing.cpu_count(), "-f",
        "fvp.mk",
        "linux"
    ]

    print("[!] Building linux...")
    make(BUILD_SCRIPT, args)

    print("[!] Building boot image...")
    run(["cp", "%s/arch/arm64/boot/Image" % NW_LINUX, OUT], cwd=ROOT)
    run(["cp", "%s/arch/arm64/boot/dts/arm/fvp-base-revc.dtb" % NW_LINUX, OUT], cwd=ROOT)
    run(["cp", PREBUILT_GRUB, OUT], cwd=ROOT)

    args = [
        "-j%d" % multiprocessing.cpu_count(), "-f",
        "fvp.mk",
    ]
    if fvp_ip != None and host_ip != None:
        args.append("boot-img-net")
        args.append("FVP_IP=" + fvp_ip) # if fvp_ip is given, boot-img tries to set fvp_ip into the fvp statically
        args.append("HOST_IP=" + host_ip) # in fvp, host_ip is used as a gateway address
    else:
        args.append("boot-img")

    make(BUILD_SCRIPT, args)

def prepare_nw_aosp(no_prebuilt_initrd):
    new_env = environ.copy()
    new_env["BUILD_CONFIG"] = "../android-kernel/build.config.gki.aarch64"
    new_env["OUT_DIR"] = NW_AOSP_OUT
    new_env["KMI_SYMBOL_LIST_STRICT_MODE"] = "0"
    new_env["SKIP_MRPROPER"] = "1"

    print("[!] Building Android kernel...")
    run("build/build.sh", cwd=NW_AOSP_BUILD_SCRIPT, new_env=new_env)

    print("[!] Building boot image...")
    args = [
        "cp",
        "%s/%s/arch/arm64/boot/Image" % (NW_AOSP_BUILD_SCRIPT, NW_AOSP_OUT),
        "%s/Image_aosp" % OUT
    ]
    run(args, cwd=ROOT)
    run(["cp", PREBUILT_AOSP_DTB, OUT], cwd=ROOT)
    if not no_prebuilt_initrd:
        run(["cp", PREBUILT_AOSP_INITRD, OUT], cwd=ROOT)
    run(["cp", PREBUILT_GRUB, OUT], cwd=ROOT)

    if not os.path.exists("%s/initrd-aosp.img" % OUT):
        print("[!] Place AOSP ramdisk image with name 'initrd-aosp.img' to %s" % OUT)
        sys.exit(1)

    print("[!] compsing boot image...")
    args = [
        "-j%d" % multiprocessing.cpu_count(), "-f",
        "fvp-android.mk",
        "boot-img" # DEPS:  $(GRUB_BIN) ${AOSP_KERNEL_BIN} ${AOSP_DTB_BIN}
    ]
    make(BUILD_SCRIPT, args)


def prepare_kvmtool(lkvm="lkvm"):
    print("[!] Building kvmtool...")
    args = [
        "CROSS_COMPILE=%s" % KVMTOOL_CROSS_COMPILE,
        "ARCH=arm64",
        "LIBFDT_DIR=%s/libfdt" % DTC,
        lkvm,
    ]
    make(KVMTOOL, args)
    run(["cp", "%s/%s" % (KVMTOOL, lkvm), OUT], cwd=ROOT)

def prepare_kvm_unit_tests():
    print("[!] Building kvm-unit-tests...")
    run(["./scripts/build-kvm-unit-tests.sh"], cwd=ROOT)
    run(["cp", "-R", "arm", "%s/%s" % (OUT, "kvm-unit-tests")], cwd=KVM_UNIT_TESTS)

def prepare_acs():
    print("[!] Building ACS...")
    run(["./scripts/build-acs.sh"], cwd=ROOT)

def prepare_tap_network(host_ip, fvp_ip, route_ip, gateway, ifname):
    print("[!] Configuring a tap network for fvp...")
    run(["./scripts/configure_tap.sh", host_ip, fvp_ip, route_ip, gateway, ifname], cwd=ROOT)

def run_fvp_tf_a_tests(debug):
    print("[!] Running fvp for tf-a-tests...")
    args = ["./FVP_Base_RevC-2xAEMvA",
            "-C", "bp.flashloader0.fname=%s/fip.bin" % OUT,
            "-C", "bp.secureflashloader.fname=%s/bl1.bin" % OUT,
            "-f", CONFIG,
            "-Q", "1000"]
    if debug:
        args += ["--cadi-server"]
    run(args, cwd=FVP_DIR)

def run_fvp_linux(debug, trace):
    print("[!] Running fvp for linux...")
    args = ["./FVP_Base_RevC-2xAEMvA",
            "-C", "bp.flashloader0.fname=%s/fip.bin" % OUT,
            "-C", "bp.secureflashloader.fname=%s/bl1.bin" % OUT,
            "-C", "bp.virtioblockdevice.image_path=%s/boot.img" % OUT,
            "-C", "bp.virtiop9device.root_path=%s" % SHARED_PATH,
            "-f", CONFIG,
            "-Q", "1000"]
    if debug:
        args += ["--cadi-server"]
    if trace:
        args += ["--plugin", "%s" % TRACE_PATH,
                "-C", "TRACE.TarmacTrace.trace_events=1",
                "-C", "TRACE.TarmacTrace.trace_instructions=1",
                "-C", "TRACE.TarmacTrace.start-instruction-count=1600000000",
                "-C", "TRACE.TarmacTrace.trace_core_registers=1",
                "-C", "TRACE.TarmacTrace.trace_vfp=1",
                "-C", "TRACE.TarmacTrace.trace_mmu=0",
                "-C", "TRACE.TarmacTrace.trace_loads_stores=1",
                "-C", "TRACE.TarmacTrace.trace_cache=0",
                "-C", "TRACE.TarmacTrace.updated-registers=1",
                "-C", "TRACE.TarmacTrace.trace-file=%s/trace.log" % OUT]
    run(args, cwd=FVP_DIR)

def run_fvp_linux_net(debug, host_ip, fvp_ip, fvp_tap_ip, realm_ip, route_ip, gateway, ifname):
    user_name = os.getlogin()
    prepare_tap_network(host_ip, fvp_ip, route_ip, gateway, ifname)
    print("[!] Running fvp for linux with the tap network..", )
    args = ["./FVP_Base_RevC-2xAEMvA",
            "-C", "bp.flashloader0.fname=%s/fip.bin" % OUT,
            "-C", "bp.secureflashloader.fname=%s/bl1.bin" % OUT,
            "-C", "bp.virtioblockdevice.image_path=%s/boot.img" % OUT,
            "-C", "bp.virtiop9device.root_path=%s" % SHARED_PATH,
            "-C", "bp.virtio_net.hostbridge.interfaceName=ARM%s" % user_name,
            "-C", "bp.virtio_net.enabled=1",
            "-f", CONFIG,
            "-Q", "1000"]
    if debug:
        args += ["--cadi-server"]
    run(args, cwd=FVP_DIR)

def run_fvp_aosp(debug):
    os.makedirs(AOSP_SHARED_PATH, exist_ok=True)
    new_env = environ.copy()
    new_env["LD_PRELOAD"] = PREBUILT_AOSP_ADB
    print("[!] Running fvp for Android...")
    args = ["./FVP_Base_RevC-2xAEMvA",
            "-C", "bp.flashloader0.fname=%s/fip.bin" % OUT,
            "-C", "bp.secureflashloader.fname=%s/bl1.bin" % OUT,
            "-C", "bp.mmc.p_mmc_file=%s/boot-aosp.img" % OUT,
            "-C", "bp.virtioblockdevice.image_path=%s/system-qemu-aosp.img" % OUT,
            "-C", "bp.virtiop9device.root_path=%s" % AOSP_SHARED_PATH,
            "-C", "bp.virtio_net.hostbridge.userNetworking=1",
            "-C", "bp.virtio_net.hostbridge.userNetPorts=5555=5555",
            "-C",  "bp.virtio_net.enabled=1",
            "-f", CONFIG,
            "-Q", "1000"]
    if debug:
        args += ["--cadi-server"]
    run(args, cwd=FVP_DIR, new_env=new_env)

def run_fvp_acs():
    run([ACS_RUN,
        "--model", FVP_BIN,
        "--bl1",  "%s/bl1.bin" % OUT,
        "--fip",  "%s/fip.bin" % OUT,
        "--acs_build_dir", ACS_BUILD], cwd=ROOT)

def place_realm_at_shared(rmm, realm_ip, fvp_tap_ip, host_ip):
    os.makedirs(SHARED_PATH, exist_ok=True)
    run(["cp", "-R", "%s/." % REALM_ROOTFS, SHARED_PATH], cwd=ROOT)
    run(["cp", "-R", "%s/realm/." % OUT, SHARED_PATH], cwd=ROOT)
    run(["cp", "%s/lkvm" % OUT, SHARED_PATH], cwd=ROOT)
    run(["cp", "-R", "%s/kvm-unit-tests" % OUT, SHARED_PATH], cwd=ROOT)
    if rmm == "islet":
        # Use the TF-RMM's one until the issue has been resolved 
        run(["cp", LAUNCH_REALM_TFRMM, LAUNCH_REALM], cwd=ROOT)
    else: # tf-rmm case
        run(["cp", LAUNCH_REALM_TFRMM, LAUNCH_REALM], cwd=ROOT)
    run(["cp", LAUNCH_REALM, SHARED_PATH], cwd=ROOT)
    run(["cp", TEST_REALM, SHARED_PATH], cwd=ROOT)
    run(["cp", CONFIGURE_NET, SHARED_PATH], cwd=ROOT)
    run(["cp", SET_REALM_IP, SHARED_PATH], cwd=ROOT)

    if realm_ip != None and fvp_tap_ip != None and host_ip != None:
        # set IP address accordingly
        run(["sed", "-i", "-e", "s/FVP_TAP_IP/%s/g" % fvp_tap_ip, "%s/configure-net.sh" % SHARED_PATH], cwd=ROOT)
        run(["sed", "-i", "-e", "s/HOST_IP/%s/g" % host_ip, "%s/configure-net.sh" % SHARED_PATH], cwd=ROOT)
        run(["sed", "-i", "-e", "s/FVP_TAP_IP/%s/g" % fvp_tap_ip, "%s/set-realm-ip.sh" % SHARED_PATH], cwd=ROOT)
        run(["sed", "-i", "-e", "s/REALM_IP/%s/g" % realm_ip, "%s/set-realm-ip.sh" % SHARED_PATH], cwd=ROOT)

        # prebuilt examples: confidential-ml
        os.makedirs(SHARED_EXAMPLES_PATH, exist_ok=True)
        run(["cp", "-R", "%s/confidential-ml" % EXAMPLES, SHARED_EXAMPLES_PATH], cwd=ROOT)
        run(["cp", "%s/confidential-ml/device/device.exe" % PREBUILT_EXAMPLES, "%s/confidential-ml/device/device.exe" % SHARED_EXAMPLES_PATH], cwd=ROOT)
        run(["cp", "-R", "%s/lib" % PREBUILT_EXAMPLES, SHARED_EXAMPLES_PATH], cwd=ROOT)
        run(["tar", "-zxvf", "%s/lib/libtensorflowlite.tar.gz" % SHARED_EXAMPLES_PATH, "-C", "%s/lib/" % SHARED_EXAMPLES_PATH], cwd=ROOT)

def clean_repo():
    run(["make", "distclean"], cwd=TF_A)
    run(["make", "distclean"], cwd=TF_A_TESTS)
    run(["make", "clean"], cwd=REALM_LINUX)
    run(["make", "clean"], cwd=KVMTOOL)

    args = ["-f", "fvp.mk", "linux-clean", "boot-img-clean"]
    make(BUILD_SCRIPT, args)

    run(["rm", "-rf", "out"], cwd=ROOT)
    run(["rm", "-rf", "build"], cwd=TF_RMM)

def get_all_realms():
    realms = []
    for dirp in glob.glob(os.path.join(REALM, "*/")):
        realms.append(os.path.basename(dirp.rstrip("/")))

    return sorted(realms)

def validate_args(args):
    nw_list = ["linux", "linux-net", "tf-a-tests", "aosp", "acs"]
    if not args.normal_world in nw_list:
        print("Please select one of the normal components:")
        print("  " + "\n  ".join(nw_list))
        sys.exit(1)

    rmm_list = ["islet", "trp", "tf-rmm"]
    if not args.rmm in rmm_list:
        print("Please select one of the rmm components:")
        print("  " + "\n  ".join(rmm_list))
        sys.exit(1)

    if args.realm is not None:
        realms = get_all_realms()
        if not args.realm in realms:
            print("Please select one of the realms:")
            print("  " + "\n  ".join(realms))
            sys.exit(1)

    if args.no_prebuilt_initrd:
        if args.run_only or args.normal_world != "aosp":
            print("--no-prebuilt-initrd is valid only when building normal world AOSP")
            sys.exit(1)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="FVP launcher for CCA")
    parser.add_argument("--normal-world", "-nw", help="A normal world component")
    parser.add_argument("--debug", "-d", help="Using debug component", action="store_true")
    parser.add_argument("--trace", "-t", help="Using trace component", action="store_true")
    parser.add_argument("--run-only", "-ro",
                        help="Running fvp without building", action="store_true")
    parser.add_argument("--build-only", "-bo",
                        help="Building components without running", action="store_true")
    parser.add_argument("--clean", "-c", help="Clean the repo", action="store_true")
    parser.add_argument("--realm", "-rm", help="A sample realm")
    parser.add_argument("--rmm", "-rmm", help="A realm management monitor (islet, trp, tf-rmm)", default="islet")
    parser.add_argument("--no-prebuilt-initrd", "-no-pi", help="Not using the prebuilt AOSP initrd", action="store_true")

    # for the network capability of FVP linux
    parser.add_argument("--host-ip", "-hip", help="the ip address of host machine", default="193.168.10.15")
    parser.add_argument("--fvp-ip", "-fip", help="the ip address that is going to be assigned to the fvp host", default="193.168.10.5")
    parser.add_argument("--fvp-tap-ip", "-ftip", help="the ip address for tap device in fvp", default="193.168.20.20")
    parser.add_argument("--realm-ip", "-reip", help="the ip address for realm", default="193.168.20.10")
    parser.add_argument("--route-ip", "-roip", help="the route ip for fvp", default="193.168.20.0")
    parser.add_argument("--gateway", "-gw", help="the gateway ip for host machine", default="193.168.10.1")
    parser.add_argument("--ifname", "-if", help="the main interface name of host machine", default="eth0")

    args = parser.parse_args()

    if args.clean:
        clean_repo()
        sys.exit(0)

    validate_args(args)

    if not args.run_only:
        prepare_rmm(args.rmm)

        if args.realm is not None:
            prepare_realm(args.realm)

        if args.normal_world == "tf-a-tests":
            prepare_tf_a_tests(args.realm)
            prepare_bootloaders(args.rmm, TFTF_BIN)
        elif args.normal_world == "aosp":
            prepare_kvmtool("lkvm-static")
            prepare_nw_aosp(args.no_prebuilt_initrd)
            prepare_bootloaders(args.rmm, PREBUILT_EDK2)
        elif args.normal_world == "acs":
            prepare_acs()
            prepare_bootloaders(args.rmm, ACS_HOST)
        else:
            prepare_kvmtool()
            prepare_kvm_unit_tests()
            prepare_nw_linux(args.fvp_ip, args.host_ip)
            prepare_bootloaders(args.rmm, PREBUILT_EDK2)

            if args.realm is not None:
                place_realm_at_shared(args.rmm, args.realm_ip, args.fvp_tap_ip, args.host_ip)
                prepare_sdk()

    if not args.build_only and args.normal_world == "tf-a-tests":
        run_fvp_tf_a_tests(args.debug)

    if not args.build_only and args.normal_world == "linux":
        run_fvp_linux(args.debug, args.trace)

    if not args.build_only and args.normal_world == "linux-net":
        run_fvp_linux_net(args.debug, args.host_ip, args.fvp_ip, args.fvp_tap_ip, args.realm_ip, args.route_ip, args.gateway, args.ifname)

    if not args.build_only and args.normal_world == "aosp":
        run_fvp_aosp(args.debug)

    if not args.build_only and args.normal_world == "acs":
        run_fvp_acs()
