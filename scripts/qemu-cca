#!/usr/bin/env python3

import os
import sys

# Ensure the script's directory is in sys.path to find cca_base
script_dir = os.path.dirname(os.path.abspath(__file__))
if script_dir not in sys.path:
    sys.path.insert(0, script_dir)

from cca_base import CCAPlatform
from config import * # General config
from config_qemu import * # QEMU specific config
from initrd import prepare_initrd # QEMU also uses prepare_initrd

# QEMU specific paths, typically from config_qemu.py
# e.g., QEMU, EDK2, etc.

class QEMUPlatform(CCAPlatform):
    def __init__(self):
        self.PREBUILT_EDK2 = PREBUILT_EDK2
        super().__init__()
        # QEMU-specific initializations if any
        # Ensure all necessary QEMU paths from config_qemu are available.

    @property
    def platform_name(self):
        return "qemu"

    @property
    def hes_address(self):
        return "127.0.0.1:54321"

    def default_optee_build_args(self, target=""):
        args = [
            "-j%d" % multiprocessing.cpu_count(),
            "-f",
            "qemu_v8_cca.mk",
        ]
        if target != "":
            args.append(target)
        args.append("ROOT=" + ROOT)
        args.append("RMM_PATH=" + TF_RMM)  # TF_RMM path for QEMU
        args.append("EDK2_PATH=" + EDK2)
        args.append("EDK2_BUILD=RELEASE")
        args.append("QEMU_PATH=" + QEMU)
        if self.args.hes:
            args.append("TF_A_PATH=" + TF_A_RSS)
            args.append("TF_A_RSE_SERIAL_HES=y")
        else:
            args.append("TF_A_PATH=" + TF_A)
        args.append("TF_A_DEBUG=0")  # QEMU build typically uses release TF-A
        args.append("BL32_DEPS=")  # No secure OS
        args.append("BL33_DEPS=")  # No edk2 build here, using prebuilt
        args.append("EDK2_BIN=" + PREBUILT_EDK2)  # Use prebuilt EDK2
        args.append("BUILD_PATH=" + BUILD_SCRIPT)
        args.append("LINUX_PATH=" + NW_LINUX)
        args.append("DEBUG=1")  # General build debug flag for optee-build
        return args

    def prepare_bootloaders(self, rmm, bl33, hes):
        # For QEMU, bootloader prep is mostly handled by optee-build (qemu_v8_cca.mk)
        # The 'arm-tf' target in optee-build builds TF-A and FIP.
        make_args = self.default_optee_build_args("arm-tf")

        if rmm == "islet":
            make_args.append("RMM_BIN=%s/rmm.bin" % OUT)

        # The optee-build script handles the specific TF-A arguments for QEMU.
        # We just need to call it.
        print("[!] Building QEMU bootloaders (bl1.bin, fip.bin) via optee-build...")
        self.make(BUILD_SCRIPT, make_args)

        # Output directory for QEMU TF-A build is typically build/qemu/release
        if hes:
            outdir = os.path.join(TF_A_RSS, "build/qemu/release") # TF_A_RSS from config
        else:
            outdir = os.path.join(TF_A, "build/qemu/release") # TF_A from config
        bl_list = ["bl1.bin", "fip.bin"]

        for bootloader in bl_list:
            outbin = os.path.join(outdir, bootloader)
            if not os.path.exists(outbin):
                print("[!] Failed to build QEMU bootloader: %s" % outbin)
                sys.exit(1)
            self.run(["cp", outbin, OUT], cwd=ROOT)

    def prepare_tf_rmm(self):
        # For QEMU, tf-rmm is also built via optee-build (qemu_v8_cca.mk)
        # The 'rmm' target in optee-build handles this.
        print("[!] Building tf-rmm for QEMU via optee-build...")
        make_args = self.default_optee_build_args("rmm")
        self.make(BUILD_SCRIPT, make_args)
        # The output tf-rmm.img should be in OUT by the optee-build script.

    def prepare_nw_linux(self):
        # For QEMU, Linux and QEMU itself are built via optee-build
        build_args_qemu = self.default_optee_build_args("qemu")
        print("[!] Building QEMU system...")
        self.make(BUILD_SCRIPT, build_args_qemu)

        build_args_linux = self.default_optee_build_args("linux")
        print("[!] Building Linux for QEMU...")
        self.make(BUILD_SCRIPT, build_args_linux)

        print("[!] Building initrd for QEMU...")
        prepare_initrd(ROOT, OUT, self.args.realm_launch, self.args.normal_world == "linux-net", self.args.platform_ip, self.args.host_tap_ip)
        # QEMU does not build a separate boot.img like FVP in this context.
        # The kernel and initrd are passed directly to QEMU.

    def prepare_run_arguments(self):
        # Original script had this as TODO.
        # QEMU arguments are different from FVP.
        # This would need to be implemented based on how QEMU is invoked.
        print("[TODO] prepare_run_arguments for QEMU - specific QEMU command line options needed.")
        # Example: return ["-s", "-S"] for gdb connect, or monitor options
        # For now, return an empty list or handle specific known args.
        run_args = []
        if self.args.debug: # Assuming debug might mean QEMU's -s and -S for GDB
            print("[!] Enabling QEMU debug (GDB stub on tcp::1234, stops CPU start)")
            run_args += ["-s", "-S"]
        # Trace, trace_toggle, no_telnet, hes are not directly mapped to simple QEMU args here.
        # These would require more detailed QEMU command line construction.
        return run_args

    def run_tf_a_tests(self):
        print("[TODO] Running QEMU for tf-a-tests...")
        # Original script had sys.exit(1)
        sys.exit(1) # Not implemented in original

    def run_nw_linux(self):
        print("[!] Running QEMU for linux...")
        # For QEMU, running is often done via the optee-build script's 'run-only' target
        # or by directly invoking QEMU with built components.
        # The original script used optee-build.
        run_args = self.default_optee_build_args("run-only")
        if self.args.rmm == "islet":
            run_args.append("EXTRA_CMDLINE=kvm-rme.save_host_context=1")
            run_args.append("QEMU_LPA2=n") # From original qemu-cca

        # Add other QEMU specific arguments from prepare_run_arguments if any
        # For example, debug arguments for QEMU itself
        qemu_specific_run_args = self.prepare_run_arguments()
        # Note: How these are combined with optee_build's run-only target needs care.
        # The optee_build script might have its own way to pass extra QEMU args.
        # If `prepare_run_arguments` returns args for direct QEMU invocation, then `make(BUILD_SCRIPT, run_args)`
        # might not be the right way if `run_args` are for QEMU, not make.
        # The original script implies `make(BUILD_SCRIPT, run_args)` is the way.
        # So, `prepare_run_arguments` for QEMU might need to return makefile variable overrides
        # or the optee_build script needs to handle EXTRA_QEMU_ARGS.

        # For now, let's assume the optee_build script handles QEMU debug flags,
        # or we pass them via make variables if the script supports it.
        # The `prepare_run_arguments` for QEMU is currently a TODO.
        # If `prepare_run_arguments` returned QEMU command line args (e.g. ["-s", "-S"]),
        # they would need to be passed to QEMU, not `make`.
        # The original `qemu-cca` did not have complex `prepare_run_arguments`.
        # It directly called `make(BUILD_SCRIPT, args)`.

        print("[!] RUNNING QEMU...")
        self.make(BUILD_SCRIPT, run_args)

    def run_nw_linux_net(self):
        user_name = os.environ['USER']
        self.prepare_tap_network()
        print(f"[!] Running QEMU for linux with the tap network for user {user_name}...")
        run_args = self.default_optee_build_args("run-only")
        run_args.append(f"TAP_NETWORK=ARM{user_name}")
        if self.args.rmm == "islet":
            run_args.append("EXTRA_CMDLINE=kvm-rme.save_host_context=1")
            run_args.append("QEMU_LPA2=n") # From original qemu-cca

        print("[!] RUNNING QEMU...")
        self.make(BUILD_SCRIPT, run_args)

    def run_acs(self):
        print("[TODO] Running QEMU for ACS...")
        # Original script had sys.exit(1)
        sys.exit(1) # Not implemented in original

    def place_prebuilt_at_shared(self):
        super().place_prebuilt_at_shared() # Call common part
        # QEMU specific prebuilt items (e.g., DTB for QEMU if different from FVP)
        # Original QEMU script did not copy fvp-base-revc.dtb or PREBUILT_GRUB here.
        # It copied Image. If a QEMU specific DTB is needed, it would be:
        # self.run([f"cp", f"{PREBUILT}/qemu-arm64.dtb", OUT], cwd=ROOT)
        pass # No QEMU-specific additions in the original script for this function.

    def _clean_platform_tf_a(self):
        # QEMU cleans TF-A via optee_build
        make_args_base = self.default_optee_build_args()
        current_make_args = list(make_args_base)
        current_make_args.append("arm-tf-clean")
        self.make(BUILD_SCRIPT, current_make_args)

    def _clean_nw_linux(self):
        # QEMU cleans linux via optee_build
        make_args_base = self.default_optee_build_args()
        current_make_args = list(make_args_base)
        current_make_args.append("linux-clean")
        self.make(BUILD_SCRIPT, current_make_args)

    def _clean_tf_rmm(self):
        # QEMU cleans tf-rmm via optee_build
        make_args_base = self.default_optee_build_args()
        current_make_args = list(make_args_base)
        current_make_args.append("rmm-clean")
        self.make(BUILD_SCRIPT, current_make_args)

    def add_platform_arguments(self, parser):
        parser.add_argument(
            "--qemu-ip",
            "-qip",
            help="the ip address that is going to be assigned to the platform host "
                 "(e.g. fvp, qemu)",
            default="192.168.10.5",
            dest="platform_ip",
        )  # Renamed conceptually
        parser.add_argument(
            "--qemu-tap-ip",
            "-ftip",
            help="the ip address for tap device in platform",
            default="192.168.20.1",
            dest="platform_tap_ip",
        )  # Renamed conceptually
        # QEMU script did not have --trace, --trace-toggle, --no-telnet
        # If QEMU specific arguments were needed, they would be added here.
        # For example, if QEMU had a different way to enable tracing:
        # parser.add_argument("--qemu-trace", help="Enable QEMU tracing", action="store_true")
        pass


if __name__ == "__main__":
    import multiprocessing
    CCAPlatform.main(QEMUPlatform)
